import{_ as i,a,b as e,c as n,d as p,e as t,f as l,g as d,h}from"./chunks/image_20220719_154244.CK3f-Ai2.js";import{_ as r,c as o,o as c,aN as k}from"./chunks/framework.ClnKacJt.js";const v=JSON.parse('{"title":"PR与issue的联动维护","description":"","frontmatter":{"title":"PR与issue的联动维护","date":"2022-07-19T14:49:19.000Z"},"headers":[],"relativePath":"01-basic-content/04-PR-and-issue.md","filePath":"01-basic-content/04-PR-and-issue.md","lastUpdated":1768579861000}'),g={name:"01-basic-content/04-PR-and-issue.md"};function F(u,s,m,b,_,y){return c(),o("div",null,[...s[0]||(s[0]=[k('<h1 id="pr与issue的联动维护" tabindex="-1">PR与issue的联动维护 <a class="header-anchor" href="#pr与issue的联动维护" aria-label="Permalink to &quot;PR与issue的联动维护&quot;">​</a></h1><p>当我们需要解决项目中的一个 bug 时，通常一个新的<code>PR</code>会伴随一个<code>issue</code>，本文将介绍仅需通过创建<code>PR</code>时一个操作，关联上<code>issue</code>，然后当<code>PR</code>被同意之后，对应关联的<code>issue</code>也将随之关闭。</p><p>同样，我先在示例项目中创建一个<code>issue</code>：</p><p><img src="'+i+`" alt="image_20220719_145415" loading="lazy"></p><p>这种时候，作为项目维护者，我们可以直接点击<code>Development</code>中的 <code>Create a branch</code> 创建一个 fix 分支，这样会自动关联上这个<code>issue</code>，同理，当该 fix 分支创建的<code>PR</code>被合并之后，<code>issue</code>也会自动关闭。</p><p>不过这里不讲此种方案，大家有兴趣可以自行体验一番。</p><p>这里讲的是我们更常见的一种操作，在本地编辑器里，基于最新的<code>main分支</code>切出一个<code>fix</code>分支，如下：</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> checkout</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pull</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> checkout</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -b</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> fix_testbug</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>然后就是在<code>fix_testbug</code>分支上进行对应问题的修复，这块儿不对赘述。</p><p>当我们感觉修复没问题了，也进行过自测了，就可以将此临时分支进行提交：</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> commit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -m</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;fix: test bug&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --set-upstream</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> fix_testbug</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>推到远程之后，我们来到 GitHub 页面中，此时可以看到 GitHub 会自动提示一个新的分支可以合并：</p><p><img src="`+a+'" alt="image_20220719_150429" loading="lazy"></p><p>可以直接点击<code>Compare &amp; pull request</code>：</p><p><img src="'+e+'" alt="image_20220719_151051" loading="lazy"></p><p>注意右侧<code>Development</code>中的说明，我们可以通过在说明中添加一些<a href="https://docs.github.com/cn/issues/tracking-your-work-with-issues/linking-a-pull-request-to-an-issue" target="_blank" rel="noreferrer">关键字</a>，从而对<code>issue</code>进行关联，并触发关闭。当然也可以先创建 PR，然后再进行关联也可以：</p><p><img src="'+n+'" alt="image_20220719_151313" loading="lazy"></p><p>完成关联的 PR，可以看到有这样的状态显示：</p><p><img src="'+p+'" alt="image_20220719_151423" loading="lazy"></p><p>这个时候，我们点击到<code>#21</code>号<code>issue</code>中，也可以看到被关联到该<code>PR</code>上了：</p><p><img src="'+t+'" alt="image_20220719_151547" loading="lazy"></p><p>现在我们将 <code>#23</code> 号<code>PR</code>进行合并，合并之后可以看到关联的<code>issue</code>也被关闭了，此次关联的临时分支也被删除了：</p><p><img src="'+l+`" alt="image_20220719_151825" loading="lazy"></p><p>以上就是项目协同中，<code>PR</code>与<code>issue</code>的联动维护。</p><hr><p><strong>另外：</strong> 这里插一个小点，当我们完成一次 PR 流程之后，作为项目主维护人，通常会再次切回到 main 分支，然后将远程被合并到 main 分支的代码拉到本地：</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> checkout</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pull</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这样执行之后，会发现本地代码竟然已经超过远程分支了：</p><p><img src="`+d+`" alt="image_20220719_154112" loading="lazy"></p><p>其中的 389fe 那次是当前远程分支的 ID，我们可以执行如下命令，与远程对齐：</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> reset</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --hard</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin/main</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">HEAD</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> is</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> now</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> at</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 389fe7b</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> fix:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> test</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bug</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (#23)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这样本地与远程就实现了对齐，在下次重新切分支，然后提交 PR 的时候，就不会出现上边那种，带了<code>几次Merge</code>的情况了。</p><p>图示如下：</p><p><img src="`+h+'" alt="image_20220719_154244" loading="lazy"></p><p>理论上这次只有一个提交，而不应该出现 3 个<code>commit</code>，就是这个原因。</p>',35)])])}const E=r(g,[["render",F]]);export{v as __pageData,E as default};
